#!/bin/bash

#pulls date as argument in the form YYYY-MM-DD and calculates day of the week

        echo "DEBUG: arguments detected: $#"

        if [ $# -gt 1 ]; then
                echo "too many arguments testing"
                exit
        elif [ $# == 0  ]; then
                echo "no date detected. please use this script as ./getDay YYYY-MM-DD"
                exit
        else
                echo "DEBUG: testing passed"                          #DEBUG
        fi

        echo $1 > searchpattern

        #if the submitted date as argument is valid, grep will output the matching line, and then pipe it to wc showing 1. If the format does not match, this will output 0
        VALIDDATE=$(grep -E "^[0-9]{4}-[0-9]{2}-[0-3][0-9]" searchpattern | wc -l)

        echo "DEBUG:date is valid if this is 1: $VALIDDATE"         #DEBUG

        sed -i 's/-/ /g' searchpattern
        echo "DEBUG:outputting date content to parse"               #DEBUG
        cat searchpattern                                           #DEBUG


        YEAR=$(cat searchpattern | awk '{ print $1 }' )
        MONTH=$(cat searchpattern | awk '{ print $2 }' )
        DAY=$(cat searchpattern | awk '{ print $3 }' )

        echo "DEBUG: Year: $YEAR"                          #DEBUG
        echo "DEBUG: Month: $MONTH"                         #DEBUG
        echo "DEBUG: DAY: $DAY"                            #DEBUG


        #Validate month and day
        if [ $MONTH -gt 12 -o $MONTH -lt 1 ]; then
                echo "invalid month. Month value detected: $MONTH"
        elif [ $DAY -gt 31 -o $DAY -lt 1 ]; then
                echo "invalid day. Day value detected: $DAY"
        fi



#pass month into this method and it sets the month code based on the input month

        if [ $MONTH -eq 1 ]; then
                if (( ($YEAR % 4 == 0 && $YEAR % 100 != 0) || $YEAR % 400 == 0 )); then
                        MCO=6
                else
                        MCO=0
                fi
        elif [ $MONTH -eq 2 ]; then
                if (( ($YEAR % 4 == 0 && $YEAR % 100 != 0) || $YEAR % 400 == 0 )); then
                        MCO=2
                else
                        MCO=3
                fi
        elif [ $MONTH -eq 3 ]; then
                MCO=3
        elif [ $MONTH -eq 4 ]; then
                MCO=6
        elif [ $MONTH -eq 5 ]; then
                MCO=1
        elif [ $MONTH -eq 6 ]; then
                MCO=4
        elif [ $MONTH -eq 7 ]; then
                MCO=6
        elif [ $MONTH -eq 8 ]; then
                MCO=2
        elif [ $MONTH -eq 9 ]; then
                MCO=5
        elif [ $MONTH -eq 10 ]; then
                MCO=0
        elif [ $MONTH -eq 11 ]; then
                MCO=3
        elif [ $MONTH -eq 12 ]; then
                MCO=5
        else
                echo "something went wrong calculating month code"
        fi



        DIVISOR=4

        YEARMOD=$((YEAR % 100))
        DYEAR=$((YEARMOD / DIVISOR))
        echo "DEBUG: DYEAR is $DYEAR"         #DEBUG

        #6 is actually the century code, 6 if 2000 or later, 0 if 1900.
        DAYMODULO=$((YEARMOD + DYEAR + DAY + MCO + 6))
        DAYNUM=$((DAYMODULO % 7))
        echo "day value is $DAYNUM"
        #(YEAR + DYEAR + DAY + MCO + 6) mod 7

        if [ $DAYNUM -eq 0 ]; then
                DAYNAME="Sunday"
        elif [ $DAYNUM -eq 1 ]; then
                DAYNAME="MONDAY"
        elif [ $DAYNUM -eq 2 ]; then
                DAYNAME="TUESDAY"
        elif [ $DAYNUM -eq 3 ]; then
                DAYNAME="WEDNESDAY"
        elif [ $DAYNUM -eq 4 ]; then
                DAYNAME="THURSDAY"
        elif [ $DAYNUM -eq 5 ]; then
                DAYNAME="FRIDAY"
        elif [ $DAYNUM -eq 6 ]; then
                DAYNAME="SATURDAY"
        fi

        echo "$MONTH/$DAY/$YEAR is a $DAYNAME"
        echo "finished"
        rm searchpattern
